open Utils
open Loc
open M.Syntax

type token = {
  ocamltype : M.BaseTypes.ocamltype option;
  terminal : M.FrontTypes.terminal;
  alias : M.FrontTypes.alias;
  _attributes : M.FrontTypes.attributes;
}

type tokens = token located list

type state = {
  grammar : M.Syntax.partial_grammar;
  tokens : token located list;
  symbols : string located list;
}

let rec string_of_params : parameter -> string = function
  | M.Syntax.ParamVar p -> p.v
  | M.Syntax.ParamApp (p, ps) ->
      spr "%s(%s)" p.v L.(ps >|= string_of_params |> String.concat ", ")
  | M.Syntax.ParamAnonymous _ -> ""

let process_symbols (grammar : partial_grammar) :
    M.FrontTypes.symbol located list =
  (* let symbols = ref [] in *)
  let f = L.flat_map in
  let aliases : (string, string) Hashtbl.t = Hashtbl.create 99 in
  let rec visit_branch (pb : parameterized_branch) =
    f visit_producer pb.pb_producers @ O.to_list pb.pb_prec_annotation
  and visit_producer ((_ide, par, _) : producer) =
    (* _ide is the name bound to the parameter (possibly generated by Menhir), which we ignore for now. *)
    visit_parameter par
  and visit_parameter (par : parameter) =
    match par with
    | ParamVar sym ->
        (* Resolve token aliases *)
        let t_name = Hashtbl.find_opt aliases sym.v in
        [ O.map_or ~default:sym (fun s -> { sym with v = s }) t_name ]
    | ParamApp (sym, pars) -> sym :: f visit_parameter pars
    | ParamAnonymous { p = _; v = branches } -> f visit_branch branches
  and visit_decl ({ p; v } : declaration located) =
    match v with
    | DToken (_, sym, alias, _) ->
        O.iter (fun a -> Hashtbl.add aliases a sym) alias;
        [ locate p sym ]
    | DTokenProperties (sym, _, _) | DStart sym -> [ locate p sym ]
    | DType (_, par) | DOnErrorReduce (par, _) -> visit_parameter par
    | DSymbolAttributes (_, _) | DGrammarAttribute _ | DCode _ | DParameter _ ->
        []
  and visit_parameterized_rule (p : parameterized_rule) =
    (p.pr_nt :: p.pr_parameters) @ f visit_branch p.pr_branches
  in
  let s_decls = f visit_decl grammar.pg_declarations in
  let s_rules = f visit_parameterized_rule grammar.pg_rules in
  s_decls @ s_rules

let load_state_from_partial_grammar (grammar : M.Syntax.partial_grammar) :
    (state, Diagnostic.t list) result =
  let symbols = process_symbols grammar in
  try
    let tokens : tokens =
      List.filter_map
        (function
          | ({
               p;
               v = M.Syntax.DToken (ocamltype, terminal, alias, _attributes);
             } :
              M.Syntax.declaration located) ->
              Some
                { p; v = ({ ocamltype; terminal; alias; _attributes } : token) }
          | _ -> None)
        grammar.pg_declarations
    in
    Ok { grammar; tokens; symbols }
  with exn ->
    let diags =
      match exn with
      | M.ParserAux.ParserError { v = msg; p }
      | M.Lexer.LexerError { v = msg; p } ->
          [
            Diagnostic.create ~message:(`String msg)
              ~range:(Range.of_lexical_positions p)
              ();
          ]
      | M.Parser.Error ->
          [
            Diagnostic.create ~message:(`String "There are syntax errors.")
              ~range:Range.first_line ();
          ]
      | _ -> []
    in
    Error diags

let load_state_from_contents (file_name : string) (file_contents : string) :
    (state, Diagnostic.t list) result =
  M.Main.load_grammar_from_contents 0 file_name file_contents
  |> load_state_from_partial_grammar

let standard_lib =
  Standard.menhir_standard_library_grammar |> load_state_from_partial_grammar
  |> R.get_exn

(** If we are inside a semantic action, we shall suggest the binders declared in
    the current branch *)
let completions_for_action (pos : Position.t) ({ grammar; _ } : state) :
    CompletionItem.t list =
  let comps =
    L.(
      let* rule = grammar.pg_rules in
      let* branch = rule.pr_branches in
      let range =
        Range.of_lexical_positions
        @@
        match branch.pb_action.expr with
        | M.IL.ETextual { p; _ } -> p
        | _ -> branch.pb_position
      in
      if Position.compare_inclusion pos range = `Inside then
        Keywords.position_keywords
        @
        let+ binder, par, _ = branch.pb_producers in
        let binder =
          O.(
            CCString.chop_prefix ~pre:"_" binder.v
            >|= ( ^ ) "$" |> get_or ~default:binder.v)
        in
        CompletionItem.create ~kind:Variable ~detail:(string_of_params par)
          ~label:binder ()
      else [])
  in
  comps

let default_completions ?(docs : (string, string) Hashtbl.t = Hashtbl.create 0)
    ({ tokens; grammar; _ } : state) : CompletionItem.t list =
  let open MenhirSyntax.Syntax in
  CCList.flat_map
    (fun (t : token located) ->
      let comp = CompletionItem.create ~kind:CompletionItemKind.Value in
      let typ =
        O.(t.v.ocamltype >|= function Declared { v; _ } | Inferred v -> v)
      in
      comp ~label:t.v.terminal ?detail:typ ()
      :: O.(
           (let+ alias = t.v.alias in
            comp ~label:alias ?detail:typ
              ~documentation:
                (`MarkupContent
                   (MarkupContent.create ~kind:Markdown
                      ~value:(spr "alias for `%s`" t.v.terminal)))
              ())
           |> to_list))
    tokens
  @ List.map
      (fun (rule : parameterized_rule) ->
        let label = rule.pr_nt.v in
        let comp =
          CompletionItem.create ~kind:CompletionItemKind.Function ~label
            ?documentation:
              O.(
                CCHashtbl.get docs label >|= fun doc ->
                `MarkupContent (MarkupContent.create ~kind:Markdown ~value:doc))
            ~labelDetails:
              (CompletionItemLabelDetails.create
                 ~detail:
                   (match rule.pr_parameters with
                   | [] -> ""
                   | _ ->
                       L.to_string ~start:"(" ~stop:")"
                         (fun { p = _; v } -> v)
                         rule.pr_parameters)
                 ())
        in
        comp ())
      grammar.pg_rules

let standard_lib_completions =
  default_completions standard_lib ~docs:Standard.menhir_standard_library_doc

let document_symbols ({ grammar = { pg_rules; _ }; tokens; _ } : state) :
    DocumentSymbol.t list =
  (* Here we extract a listing of the defined tokens and grammar rules. *)
  L.(
    (let+ t = tokens in
     let range = Range.of_lexical_positions t.p in
     DocumentSymbol.create ~kind:SymbolKind.Constant ~name:t.v.terminal ~range
       ~selectionRange:range
       ~detail:(O.get_or ~default:"" t.v.alias)
       ())
    @ let+ rule = pg_rules in
      let range = Range.of_lexical_positions rule.pr_nt.p in
      DocumentSymbol.create ~kind:SymbolKind.Function ~name:rule.pr_nt.v ~range
        ~selectionRange:range
        ~children:
          (rule.pr_branches
          |> L.mapi @@ fun i branch ->
             let range = Range.of_lexical_positions branch.pb_position in
             DocumentSymbol.create ~kind:SymbolKind.Enum
               ~name:(spr "<branch %d>" i) ~range ~selectionRange:range
               ~children:
                 (let+ binder, par, _ = branch.pb_producers in
                  let range = Range.of_lexical_positions binder.p in
                  let binder =
                    O.(
                      CCString.chop_prefix ~pre:"_" binder.v
                      >|= ( ^ ) "$" |> get_or ~default:binder.v)
                  in
                  DocumentSymbol.create ~kind:SymbolKind.Variable ~name:binder
                    ~range ~selectionRange:range ~detail:(string_of_params par)
                    ())
               ())
        ())

let symbol_at_position (state : state) (pos : Position.t) :
    (Range.t * string located) option =
  L.find_map
    (fun (s : string located) ->
      let rng = Range.of_lexical_positions s.p in
      let res = Position.compare_inclusion pos rng = `Inside in
      if res then Some (rng, s) else None)
    state.symbols

(** Produce hover information at a particular position. For:
    - token aliases, we display their full name;
    - standard library rules, their documentation; *)
let hover (state : state) ~(pos : Position.t) : Hover.t option =
  let open O in
  let* rng, sym = symbol_at_position state pos in
  let+ contents, range =
    (let+ stdlib_doc =
       Hashtbl.find_opt Standard.menhir_standard_library_doc sym.v
     in
     (stdlib_doc, rng))
    <+> L.find_map
          (fun ({ v = t; _ } : token located) ->
            if_
              (fun _ -> t.alias = Some sym.v || t.terminal = sym.v)
              ( O.map_or ~default:""
                  (function
                    | M.BaseTypes.Declared { v; _ } | M.BaseTypes.Inferred v ->
                        spr "<%s> " v)
                  t.ocamltype
                ^ t.terminal
                |> md_fenced,
                rng ))
          state.tokens
  in
  Hover.create
    ~contents:
      (`MarkupContent
         (MarkupContent.create ~kind:MarkupKind.Markdown ~value:contents))
    ~range ()

let diagnostics (_state : state) : Lsp.Types.Diagnostic.t list =
  (* let open MenhirSyntax.Syntax in
  List.map
    (function
      | { p; v = { terminal; _ } } ->
          Diagnostic.create ~severity:DiagnosticSeverity.Information
            ~message:(`String (Printf.sprintf "%s is a nice token" terminal))
            ~range:(lsp_range_of_menhir_range p)
            ())
    state.tokens *)
  []

let references (state : state) ~uri ~(pos : Position.t) : Location.t list =
  (let open O in
   let* _sym_range, sym = symbol_at_position state pos in
   (* Is it a token alias? If so, use token's full name. *)
   let sym_name =
     get_or ~default:sym.v
       (L.find_map
          (fun t ->
            let* alias = t.v.alias in
            if_ (fun _ -> alias = sym.v) alias)
          state.tokens)
   in
   epr "Looking for references of %s\n" sym_name;
   Some
     (L.filter_map
        (fun { v; p } ->
          epr "Comparing with %s at %s\n" v
            Range.(show @@ of_lexical_positions p);
          if_
            (fun _ -> v = sym_name)
            (Location.create ~uri ~range:(Range.of_lexical_positions p)))
        state.symbols))
  |> O.to_list |> L.flatten

let definition (state : state) ~uri ~(pos : Position.t) : Locations.t =
  let open O in
  (* Get the symbol under the cursor, if any. *)
  (let* _sym_range, sym = symbol_at_position state pos in
   (* Search for the symbol in the terminals or in the nonterminals. *)
   let+ def =
     L.find_map
       (fun (t : token located) ->
         if_
           (fun _ -> String.equal t.v.terminal sym.v || t.v.alias = Some sym.v)
           (locate t.p t.v.terminal))
       state.tokens
     <+> L.find_map
           (fun (r : M.Syntax.parameterized_rule) ->
             if_ (fun _ -> String.equal r.pr_nt.v sym.v) r.pr_nt)
           state.grammar.pg_rules
   in
   Location.create ~range:(Range.of_lexical_positions def.p) ~uri)
  |> O.to_list
  |> fun locs -> `Location locs

let completions (state : state) ~(pos : Position.t) : CompletionItem.t list =
  match completions_for_action pos state with
  | [] ->
      default_completions state @ standard_lib_completions
      @ Keywords.declarations
  | l -> l

let prepare_rename (state : state) ~(pos : Position.t) : Range.t option =
  let open O in
  let+ sym_range, _ = symbol_at_position state pos in
  sym_range

let rename (state : state) ~uri ~(pos : Position.t) ~(newName : string) :
    WorkspaceEdit.t =
  let edits : TextEdit.t list =
    O.(
      let+ _sym_range, sym = symbol_at_position state pos in
      L.filter_map
        (fun (s : string located) ->
          if_
            (fun _ -> CCString.equal s.v sym.v)
            (* (TextEdit.create ~newText:newName
              ~range:(Range.of_lexical_positions s.p)) *)
            (TextEdit.create ~newText:newName
               ~range:(Range.of_lexical_positions s.p)))
        state.symbols)
    |> O.to_list |> L.flatten
  in
  WorkspaceEdit.create ~changes:[ (uri, edits) ] ()

let code_actions (state : state) ~uri ~(range : Range.t) : CodeActionResult.t =
  let open O in
  let* sym_range, sym = symbol_at_position state range.start in
  (* Is is a token declaration? Does it *not* have an alias? *)
  L.flat_map
    (function
      | { v = { terminal; alias = None; _ }; _ } when terminal = sym.v ->
          [
            `Command
              (Command.create
                 ~title:
                   ("Define an alias for " ^ terminal
                  ^ " and replace all its occurrences")
                 ~command:"menhir-lsp-client.promptAlias"
                 ~arguments:
                   (* send the token name and the ranges of its occurrences to the client *)
                   [
                     `String terminal;
                     Range.yojson_of_t sym_range;
                     DocumentUri.yojson_of_t uri;
                     `List
                       (L.filter_map
                          (fun sym' ->
                            let range = Range.of_lexical_positions sym'.p in
                            if_
                              (fun _ ->
                                sym.v = sym'.v
                                && Range.compare sym_range range <> Eq)
                              (Range.yojson_of_t range))
                          state.symbols);
                   ]
                 ());
          ]
      | { v = { terminal; alias = Some alias; _ }; _ } when terminal = sym.v ->
          [
            `CodeAction
              (CodeAction.create ~kind:Refactor
                 ~title:
                   ("Replace all occurrences of " ^ terminal ^ " with alias")
                 ~edit:
                   (WorkspaceEdit.create
                      ~changes:
                        [
                          ( uri,
                            L.filter_map
                              (fun sym ->
                                let range = Range.of_lexical_positions sym.p in
                                if_
                                  (fun _ ->
                                    sym.v = terminal
                                    && Range.compare sym_range range <> Eq)
                                  (TextEdit.create ~newText:alias ~range))
                              state.symbols );
                        ]
                      ())
                 ());
          ]
      | _ -> [])
    state.tokens
  |> some
